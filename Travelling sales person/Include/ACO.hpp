#ifndef TRAVELLING_SALES_PERSON_ACO_HPP
#define TRAVELLING_SALES_PERSON_ACO_HPP
#include <vector>
#include <cmath>
#include <string>
#include <random>
#include <iostream>
#include <algorithm>
#include "structs.hpp"

class ACO {
public:
    ACO(std::vector<place> places, int maxIterations, int antNumber, float initialPheromone,
        float evaporationRate, float explorationRate, float alpha, float beta):
            places_(places), antNumber_(antNumber),
            evaporationRate_(evaporationRate), maxIterations_(maxIterations), explorationRate_(explorationRate),
            lowestCost(9999999.0), beta_(beta), alpha_(alpha){

        //A for loop which calculates the cost for traveling between the different places
        for (int i = 0; i < places.size(); i++) {
            for (int j = i+1; j < places.size(); j++) {
                double distance = sqrt(pow((places[i].latitude - places[j].latitude), 2) +
                                       pow((places[i].longitude - places[j].longitude), 2));
                totalDistance += distance;
                //The code for the key is made by Deepseek
                std::string key = (places[i].name < places[j].name)
                                  ? places[i].name + places[j].name
                                  : places[j].name + places[i].name;
                distances.emplace_back(key, distance, initialPheromone);
            }
        }
    }

    void moveAnts() {
        //Creates a random float generator
        std::random_device rd;
        std::default_random_engine generator(rd());
        std::uniform_real_distribution<float> floatDis(0, 1);
        std::vector<ant> ants;

        for (int i = 0; i < antNumber_; i++) {
            //Creates the ant
            ant currentAnt(places_[0]);
            currentAnt.visitedLocations.push_back(places_[0].name);
            //A while loop that runs if not all locations are visited
            while (currentAnt.visitedLocations.size() < places_.size() + 1) {
                place nextPlace = places_[0];
                std::vector<place> unvisited;
                //Creates a vector with all the unvisited locations by the ant
                for (const place currentPlace : places_) {
                    if (std::find(currentAnt.visitedLocations.begin(),
                                  currentAnt.visitedLocations.end(),
                                  currentPlace.name) == currentAnt.visitedLocations.end()) {
                        unvisited.push_back(currentPlace);
                    }
                }
                //Checks if the next position should be random or not throug the random generator
                if (floatDis(generator) <= explorationRate_) {
                    //Finds the next random location
                    std::uniform_int_distribution<int> intDis(0, unvisited.size()-1);
                    nextPlace = unvisited[intDis(generator)];
                } else {
                    float totalWeight = 0.0f;
                    std::vector<float> weights;
                    //Calculates all the pheromone levels for the possible paths
                    for (const auto& city : unvisited) {
                        std::string key = (currentAnt.location.name < city.name)
                                          ? currentAnt.location.name + city.name
                                          : city.name + currentAnt.location.name;
                        //The std::find part of the code is generated by Deepseek
                        auto it = std::find_if(distances.begin(), distances.end(),
                                               [&key](const auto& pd) { return pd.placeToPlace == key; });
                        if (it != distances.end()) {
                            float pheromone = it->phermoneLevel;
                            float distance = it->euclidianDistance;
                            float weight = pow(pheromone, alpha_) * pow(1.0/distance, beta_);
                            weights.push_back(weight);
                            totalWeight += weight;
                        }
                    }
                    //Creates a random number to select the next path
                    std::uniform_real_distribution<float> dist(0, totalWeight);
                    float threshold = dist(generator);
                    float accumulated = 0.0f;

                    for (int j = 0; j < unvisited.size(); ++j) {
                        accumulated += weights[j];
                        if (accumulated >= threshold) {
                            nextPlace = unvisited[j];
                            break;
                        }
                    }
                }

                std::string key = (currentAnt.location.name < nextPlace.name)
                                  ? currentAnt.location.name + nextPlace.name
                                  : nextPlace.name + currentAnt.location.name;
                auto it = std::find_if(distances.begin(), distances.end(),
                                       [&key](const auto& pd) { return pd.placeToPlace == key; });
                //Moves the ant and calculates new pheromone level
                if (it != distances.end()) {
                    std::string key = (currentAnt.location.name < nextPlace.name)
                          ? currentAnt.location.name + nextPlace.name
                          : nextPlace.name + currentAnt.location.name;
                    currentAnt.tripsTaken.push_back(key);
                    currentAnt.location = nextPlace;
                    currentAnt.visitedLocations.push_back(nextPlace.name);
                    currentAnt.cost += it->euclidianDistance;
                }
            }

            std::string key = (currentAnt.location.name < places_[0].name)
                              ? currentAnt.location.name + places_[0].name
                              : places_[0].name + currentAnt.location.name;
            auto it = std::find_if(distances.begin(), distances.end(),
                                   [&key](const auto& pd) { return pd.placeToPlace == key; });
            //Moves the ant and calculates new pheromone level
            if (it != distances.end()) {
                std::string key = (currentAnt.location.name < places_[0].name)
                                  ? currentAnt.location.name + places_[0].name
                                  : places_[0].name + currentAnt.location.name;
                currentAnt.tripsTaken.push_back(key);
                currentAnt.visitedLocations.push_back(places_[0].name);
                currentAnt.cost += it->euclidianDistance;
            }

            //Updates the lowest cost
            if (currentAnt.cost < lowestCost) {
                lowestCost = currentAnt.cost;
                bestVisitList = currentAnt.visitedLocations;
            }
            ants.push_back(currentAnt);
        }

        //Evaporate pheromones
        for (int i = 0; i < distances.size(); i++) {
            distances[i].phermoneLevel *= (1 - evaporationRate_);
        }

        for (int k = 0; k < ants.size(); k++){
            for (int i = 0; i < ants[k].tripsTaken.size(); i++) {
                for (int j = 0; j < distances.size(); j++) {
                    if (distances[j].placeToPlace == ants[k].tripsTaken[i]) {
                        distances[j].phermoneLevel += 1.0f/ants[k].cost;
                    }
                }
            }
        }

        iterations_++;
        checkFinish();
    }

private:

    void checkFinish() {
        //Checks if the loop is finished and prints lowest cost
        if (iterations_ == maxIterations_) {
            for (const auto& city : bestVisitList) {
                std::cout << "\"" << city << "\"," << std::endl;
            }
            std::cout << "Lowest cost: " << lowestCost << std::endl;
        } else if (iterations_ < maxIterations_){
            std::cout << lowestCost << ", " << std::endl;
        }
    }

private:
    std::vector<placeDistance> distances;
    std::vector<place> places_;
    int antNumber_;
    int maxIterations_;
    int iterations_ = 0;
    float evaporationRate_;
    float lowestCost;
    float explorationRate_;
    float beta_;
    float alpha_;
    float totalDistance = 0;
    std::vector<std::string> bestVisitList;
};

#endif // TRAVELLING_SALES_PERSON_ACO_HPP